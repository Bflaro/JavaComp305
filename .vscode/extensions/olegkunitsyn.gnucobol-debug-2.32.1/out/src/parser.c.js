"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const readline = require("n-readlines");
const nativePathFromPath = require("path");
const debugger_1 = require("./debugger");
const nativePath = {
    resolve: function (...args) {
        const nat = nativePathFromPath.resolve(...args);
        if (process.platform === "win32" && this.cobcpath === "docker" && this.gdbpath === "docker") {
            return nat.replace(/.*:/, s => "/" + s.toLowerCase().replace(":", "")).replace(/\\/g, "/");
        }
        return nat;
    },
    basename: function (path) {
        return nativePathFromPath.basename(path);
    },
    isAbsolute: function (path) {
        return nativePathFromPath.isAbsolute(path);
    },
    join: function (...args) {
        return nativePathFromPath.join(...args);
    }
};
const procedureRegex = /\/\*\sLine:\s([0-9]+)(\s+:\sEntry\s)?/i;
const procedureFixRegex = /#line\s([0-9]+)\s".*\.c"/i;
const attributeRegex = /static\sconst\scob_field_attr\s(a_[0-9]+).*\{(0x\d+),\s*([0-9-]*),\s*([0-9-]*),\s*(0x\d{4}),.*/i;
const dataStorageRegex = /static\s+(.*)\s+(b_[0-9]+)(\;|\[\d+\]).*\/\*\s+([0-9a-z_\-]+)\s+\*\//i;
const fieldRegex = /static\s+cob_field\s+([0-9a-z_]+)\s+\=\s+\{(\d+)\,\s+([0-9a-z_]+).+\&(a_\d+).*\/\*\s+([0-9a-z_\-]+)\s+\*\//i;
const fileIncludeRegex = /#include\s+\"([0-9a-z_\-\.\s]+)\"/i;
const fileCobolRegex = /\/\*\sGenerated from\s+([0-9a-z_\-\/\.\s\\:]+)\s+\*\//i;
const functionRegex = /\/\*\sProgram\slocal\svariables\sfor\s'(.*)'\s\*\//i;
const versionRegex = /\/\*\sGenerated by\s+cobc\s([0-9a-z\-\.]+)\s+\*\//i;
class Line {
    constructor(filePathCobol, lineCobol, filePathC, lineC) {
        this.fileCobol = filePathCobol;
        this.lineCobol = lineCobol;
        this.fileC = filePathC;
        this.lineC = lineC;
    }
    toString() {
        return `${this.fileCobol}:${this.lineCobol} > ${this.fileC}:${this.lineC}`;
    }
}
exports.Line = Line;
class SourceMap {
    constructor(cwd, filesCobol) {
        this.lines = new Array();
        this.variablesByCobol = new Map();
        this.variablesByC = new Map();
        this.attributes = new Map();
        this.dataStorages = new Map();
        this.cwd = cwd;
        filesCobol.forEach(e => {
            this.parse(nativePath.basename(e.split('.').slice(0, -1).join('.') + '.c'));
        });
    }
    parse(fileC) {
        let nat = fileC;
        if (!nativePath.isAbsolute(fileC)) {
            nat = nativePathFromPath.resolve(this.cwd, fileC);
            fileC = nativePath.resolve(this.cwd, fileC);
        }
        const basename = nativePath.basename(fileC);
        const cleanedFile = basename.substring(0, basename.lastIndexOf(".c"));
        let lineNumber = 0;
        const reader = new readline(process.platform === "win32" ? nat : fileC);
        let row;
        let fileCobol;
        let functionName;
        while (row = reader.next()) {
            const line = row.toString();
            let match = fileCobolRegex.exec(line);
            if (match) {
                if (!nativePath.isAbsolute(match[1])) {
                    fileCobol = nativePath.resolve(this.cwd, match[1]);
                }
                else {
                    fileCobol = match[1];
                }
            }
            match = functionRegex.exec(line);
            if (match) {
                functionName = match[1].toLowerCase() + "_";
            }
            match = procedureRegex.exec(line);
            if (match && !match[2]) {
                if (this.lines.length > 0 && fileNameCompare(this.lines[this.lines.length - 1].fileCobol, fileCobol) && this.lines[this.lines.length - 1].lineCobol === parseInt(match[1])) {
                    this.lines.pop();
                }
                this.lines.push(new Line(fileCobol, parseInt(match[1]), fileC, lineNumber + 2));
            }
            // fix new codegen
            match = procedureFixRegex.exec(line);
            if (match && this.lines.length > 0) {
                let line = this.lines.pop();
                line.lineC = parseInt(match[1]);
                this.lines.push(line);
            }
            match = attributeRegex.exec(line);
            if (match) {
                const attribute = new debugger_1.Attribute(match[1], debugger_1.VariableType[match[2]], parseInt(match[3]), parseInt(match[4]), match[5]);
                this.attributes.set(`${cleanedFile}.${match[1]}`, attribute);
            }
            match = dataStorageRegex.exec(line);
            if (match) {
                let size = null;
                if (match[3].startsWith("[")) {
                    size = parseInt(match[3].substring(1, match[3].length - 1));
                }
                const dataStorage = new debugger_1.DebuggerVariable(match[4], match[2], functionName, new debugger_1.Attribute(null, debugger_1.VariableType[match[1]], 0, 0), size);
                this.dataStorages.set(`${functionName}.${dataStorage.cName}`, dataStorage);
                this.variablesByC.set(`${functionName}.${dataStorage.cName}`, dataStorage);
                this.variablesByCobol.set(`${functionName}.${dataStorage.cobolName.toUpperCase()}`, dataStorage);
            }
            match = fieldRegex.exec(line);
            if (match) {
                const attribute = this.attributes.get(`${cleanedFile}.${match[4]}`);
                const dataStorage = this.dataStorages.get(`${functionName}.${match[3]}`);
                const field = new debugger_1.DebuggerVariable(match[5], match[1], functionName, attribute, parseInt(match[2]));
                this.variablesByC.set(`${functionName}.${field.cName}`, field);
                if (dataStorage) {
                    dataStorage.addChild(field);
                    this.variablesByCobol.set(`${functionName}.${dataStorage.cobolName.toUpperCase()}.${field.cobolName.toUpperCase()}`, field);
                }
                else {
                    this.variablesByCobol.set(`${functionName}.${field.cobolName.toUpperCase()}`, field);
                }
            }
            match = fileIncludeRegex.exec(line);
            if (match) {
                this.parse(match[1]);
            }
            match = versionRegex.exec(line);
            if (match) {
                this.version = match[1];
            }
            lineNumber++;
        }
    }
    getVariablesByC() {
        return this.variablesByC.values();
    }
    getVariablesByCobol() {
        return this.variablesByCobol.values();
    }
    getLinesCount() {
        return this.lines.length;
    }
    getVariablesCount() {
        return this.variablesByC.size;
    }
    getVariableByC(varC) {
        if (this.variablesByC.has(varC)) {
            return this.variablesByC.get(varC);
        }
        return null;
    }
    findVariableByCobol(functionName, name) {
        for (const key of this.variablesByCobol.keys()) {
            if (key.startsWith(functionName) && key.endsWith(`.${name.toUpperCase()}`)) {
                return this.variablesByCobol.get(key);
            }
        }
        return null;
    }
    getVariableByCobol(path) {
        return this.variablesByCobol.get(path);
    }
    hasLineCobol(fileC, lineC) {
        if (!nativePath.isAbsolute(fileC)) {
            fileC = nativePath.join(this.cwd, fileC);
        }
        return this.lines.some(e => e.fileC === fileC && e.lineC === lineC);
    }
    hasLineC(fileCobol, lineCobol) {
        if (!nativePath.isAbsolute(fileCobol)) {
            fileCobol = nativePath.join(this.cwd, fileCobol);
        }
        return this.lines.some(e => fileNameCompare(e.fileCobol, fileCobol) && e.lineCobol === lineCobol);
    }
    getLineC(fileCobol, lineCobol) {
        var _a;
        if (!nativePath.isAbsolute(fileCobol)) {
            fileCobol = nativePath.join(this.cwd, fileCobol);
        }
        return (_a = this.lines.find(e => fileNameCompare(e.fileCobol, fileCobol) && e.lineCobol === lineCobol)) !== null && _a !== void 0 ? _a : new Line('', 0, '', 0);
    }
    getLineCobol(fileC, lineC) {
        var _a;
        if (!nativePath.isAbsolute(fileC)) {
            fileC = nativePath.join(this.cwd, fileC);
        }
        return (_a = this.lines.find(e => e.fileC === fileC && e.lineC === lineC)) !== null && _a !== void 0 ? _a : new Line('', 0, '', 0);
    }
    getVersion() {
        return this.version;
    }
    toString() {
        let out = `SourceMap created: lines ${this.lines.length}, vars ${this.variablesByC.size}\n`;
        this.lines.forEach(e => {
            out += e.toString() + "\n";
        });
        this.variablesByC.forEach((value, key) => {
            var _a;
            out += `${key}[${(_a = value.attribute) === null || _a === void 0 ? void 0 : _a.cName}] > ${value.cobolName}\n`;
        });
        this.variablesByCobol.forEach((value, key) => {
            var _a;
            out += `${key}[${(_a = value.attribute) === null || _a === void 0 ? void 0 : _a.cName}] > ${value.cName}\n`;
        });
        return out;
    }
}
exports.SourceMap = SourceMap;
function fileNameCompare(fileNameOne, fileNameTwo) {
    if (process.platform === "win32")
        return fileNameOne.toUpperCase() === fileNameTwo.toUpperCase();
    else
        return fileNameOne === fileNameTwo;
}
//# sourceMappingURL=parser.c.js.map